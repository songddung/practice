### 비트 연산
# bit : 0과 1을 표현하는 정보의 단위
# Byte : 8-bit를 묶어 1 Byte라고 한다.

### 연산
# cpu는 0과 1로 다루어 동작하며, 내부적으로 비트 연산을 사용하여 덧셈, 뺄셈, 곱셈등을 계산

### 비트연산 챕터의 목적
# 사람의 사칙연산이 아닌 컴퓨터의 비트연산을 이해
# 나아가, 비트연산을 활용한 코딩 방법 학습

### AND와 OR 비트연산자 이해
# AND : 둘 다 1일때만 1 == &
# OR : 둘중 하나만이라도 1이면 1 == |

### XOR와 NOT 연산자
# ^ : XOR연산자, OR처럼 동작되는데, 둘 다 1인 경우 0

# 어떤 값이던 특정 수로 2회 XOR를 하면 원래 수로 돌아온다.
# 7070 ^ 1004 = 6258
# 6258 ^ 1004 = 7070


# 비트 연산자
## Shift
### Left Shift (<<) : 특정 수 만큼 비트를 왼쪽으로 밀어낸다. == 2배 수
### Right Shift (>>) : 특정 수 만큼 비트를 오른쪽으로 밀어낸다. == 2로 나눈 몫


print(1 << 1)  # 2
print(1 << 2)  # 4
print(1 << 3)  # 8
print(1 << 4)  # 16
print(1 << 4 >> 3)  # *4 , //3
num = 1
for _ in range(5):
    num = num << 1

binary_num = bin(num)[2:]
print(binary_num)

print('================================================')

# 부분집합의 수를 바로 구할 수 있다
arr = [1, 2, 3, 4]
print(f'부분집합의 수 : {1 << len(arr)}')

# 응용
# i & (1<<n)  : i의 n번째 비트가 1인지 확인
for i in range(1 << len(arr)):
    for idx in range(len(arr)):
        if i & (1 << idx):  # i의 idx번째 bit가 1인지 확인
            print(arr[idx], end=" ")
    print()

print('=========================================')
for i in range(1 << len(arr)):  # 합이 10인 부분 집합 리턴
    subset = []
    total = 0
    for idx in range(len(arr)):
        if i & (1 << idx):
            subset.append(arr[idx])
            total += arr[idx]
        if total == 10:
            print(f"f'부분집합 : {subset}")

print('=================================================')

# 음수 표현 방법
### 컴퓨터는 음수를 '2의 보수'로 관리
### 맨 앞자리 bit(MSB)는 음수 or 양수를 구분하는 비트

# 컴퓨터의 음수 표현
### 최초 컴퓨터는 연산느림, 효율적으로 구현해야함 -> 즉, 뺄셈을 안쓰는 방식을 채택

# 1. 부호 비트만 사용
### - 숫자표현엔 문제 x
### - 연산자 사용 시에 문제 발생

# 2. 1의 보수
### - 각 비트를 뒤집어서 표현하자
### - 문제점 : 0을 표현하는 방법이 2개가 생김

# 3. 2의 보수
### - 각 비트를 모두 뒤집고 1을 더하자
### - 덧셈 연산 시 over bit는 삭제

# 2의 보수를 취한 수를, 한번 더 2의 보수를 취하면 원래의 값으로 돌아온다

# bitwise NOT(complement)연산자
### ~연산자 : 모든 비트를 반전
print(bin(4))
print(bin(~4))
print(bin(~-4))


print('============================================')

# 실수

### 출력 : 파이썬은 f-string 문법 지향

# 소수점 출력
### {t2:.2f} : t2 값을 소수점 둘째자리에서 반올림하여 표현

# 컴퓨터는 실수를 내부적으로 근사적으로 관리
### 실수는 정확한 값이 아니라 근사 값으로 저장되는데 이때 생기는 작은 오차가 계산과정중 다른 결과를 가져옴
### == 부동소수점 오류

# 실수의 표현
### 컴퓨터는 실수 표현을 위해 부동 소수점 표기법 사용
### IEEE 754 : 국제표준

# 부동 소수점 : 소수점의 위치를 고정 시켜 표현
### 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현
import struct
def float_to_binary(num):
    """실수를 이진 문자열로 변환하는 함수"""
    bits = ''.join(bin(byte).replace('0b', '').rjust(8, '0') for byte in struct.pack('!d', num))
    return bits

print(float_to_binary(12.357))